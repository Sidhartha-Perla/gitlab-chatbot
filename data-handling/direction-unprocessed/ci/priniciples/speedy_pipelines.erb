### Speedy, Reliable Pipelines

GitLab CI/CD was built from the ground up with speed and scalability in mind. This is reflected both in the [product design](https://docs.gitlab.com/ee/ci/) as well as [Continuous Integration](/direction/verify/continuous_integration/) and [Verify](https://about.gitlab.com/direction/ops/#verify) product direction. To enable our users to go from monthly shipping releases to truly enabling continuous delivery, everything that we do must be concerned with the scalability and speed of continuous integration and testing. Not that [sword fighting on office chairs](https://xkcd.com/303/) isn't fun, but we do want people to be able to **contribute at the speed of development**. We will achieve this through automated tuning where possible, and faster feedback on potential issues were not.

[Wall clock time](https://en.wikipedia.org/wiki/Elapsed_real_time) for a pipeline is an important measure here. You feel this many times every day -  when you make a commit and a pipeline starts, but you need to go have lunch before you see the result, that's not fun for anyone. We produce best practices to ensure your [pipeline is efficient](https://docs.gitlab.com/ee/ci/pipelines/pipeline_efficiency.html). Issues like our [auto-determining the test parallelization factor](https://gitlab.com/gitlab-org/gitlab/issues/12282) and running [tests likely to fail first](https://gitlab.com/gitlab-org/gitlab/issues/34364) represent how we want GitLab CI/CD to automatically find and solve these problems for you. We are building more speed into the workflow itself with features like the [dependency proxy](https://about.gitlab.com/direction/package/#dependency-proxy) to help speed up the tax you pay on every job invocation setting up the environment, fetching dependencies, and so on.
